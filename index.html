<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="LIFE WAS LIKE A BOX OF CHOCOLATES">
<meta name="keywords" content="Life Study Work">
<meta property="og:type" content="website">
<meta property="og:title" content="Hey Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hey Blog">
<meta property="og:description" content="LIFE WAS LIKE A BOX OF CHOCOLATES">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hey Blog">
<meta name="twitter:description" content="LIFE WAS LIKE A BOX OF CHOCOLATES">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hey Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hey Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/22/Makefile入门8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hey Z">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信头像.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hey Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/Makefile入门8/" itemprop="url">Makefile入门8</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T14:49:35+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="make隐含规则"><a href="#make隐含规则" class="headerlink" title="make隐含规则"></a><strong>make隐含规则</strong></h1><p>​        转自《跟我一起写Makefile》</p>
<p>​        <a href="https://seisman.github.io/how-to-write-makefile/index.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
<p>​        在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>
<p>一、使用隐含规则</p>
<p>例如，我们有下面的一个Makefile：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo : foo.o bar.o</span><br><span class="line">cc –o foo foo.o bar.o <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把[.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">	cc –c foo.c <span class="variable">$(CFLAGS)</span></span><br><span class="line">bar.o : bar.c</span><br><span class="line">	cc –c bar.c <span class="variable">$(CFLAGS)</span></span><br></pre></td></tr></table></figure>
<p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.p</span><br></pre></td></tr></table></figure>
<p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过“foo.c”调用C的编译器生成foo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p>
<p>二、隐含规则示例</p>
<p>有时，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表”（也就一系统定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out, .a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。</p>
<p>1、编译C程序的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;.o”的目标的依赖目标会自动推导为“&lt;n&gt;;.c”，并且其生成命令是“<span class="variable">$(CC)</span> –c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span>”</span><br></pre></td></tr></table></figure>
<p>2、编译C++程序的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;.o”的目标的依赖目标会自动推导为“&lt;n&gt;;.cc”或是“&lt;n&gt;;.C”，并且其生成命令是“<span class="variable">$(CXX)</span> –c <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span>”。</span><br><span class="line">（建议使用“.cc”作为C++源文件的后缀，而不是“.C”）</span><br></pre></td></tr></table></figure>
<p>3、编译Pascal程序的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;.o”的目标的依赖目标会自动推导为“&lt;n&gt;;.p”，并且其生成命令是“<span class="variable">$(PC)</span> –c  <span class="variable">$(PFLAGS)</span>”。</span><br></pre></td></tr></table></figure>
<p>4、编译Fortran/Ratfor程序的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">“&lt;n&gt;;.o”的目标的依赖目标会自动推导为“&lt;n&gt;;.r”或“&lt;n&gt;;.F”或“&lt;n&gt;;.f”，并且其生成命令是:</span></span><br><span class="line">    “.f”  “<span class="variable">$(FC)</span> –c  <span class="variable">$(FFLAGS)</span>”</span><br><span class="line">    “.F”  “<span class="variable">$(FC)</span> –c  <span class="variable">$(FFLAGS)</span> <span class="variable">$(CPPFLAGS)</span>”</span><br><span class="line">    “.f”  “<span class="variable">$(FC)</span> –c  <span class="variable">$(FFLAGS)</span> <span class="variable">$(RFLAGS)</span>”</span><br></pre></td></tr></table></figure>
<p>5、预处理Fortran/Ratfor程序的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;.f”的目标的依赖目标会自动推导为“&lt;n&gt;;.r”或“&lt;n&gt;;.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：</span><br><span class="line">    “.F”  “<span class="variable">$(FC)</span> –F <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(FFLAGS)</span>”</span><br><span class="line">    “.r”  “<span class="variable">$(FC)</span> –F <span class="variable">$(FFLAGS)</span> <span class="variable">$(RFLAGS)</span>”</span><br></pre></td></tr></table></figure>
<p>6、编译Modula-2程序的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;.sym”的目标的依赖目标会自动推导为“&lt;n&gt;;.def”，并且其生成命令是：“<span class="variable">$(M2C)</span> <span class="variable">$(M2FLAGS)</span> <span class="variable">$(DEFFLAGS)</span>”。</span><br><span class="line">“&lt;n.o&gt;;” 的目标的依赖目标会自动推导为“&lt;n&gt;;.mod”，并且其生成命令是：“<span class="variable">$(M2C)</span> <span class="variable">$(M2FLAGS)</span> <span class="variable">$(MODFLAGS)</span>”。</span><br></pre></td></tr></table></figure>
<p>7、汇编和汇编预处理的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;.o” 的目标的依赖目标会自动推导为“&lt;n&gt;;.s”，默认使用编译器“as”，并且其生成命令是：“<span class="variable">$(AS)</span> <span class="variable">$(ASFLAGS)</span>”。</span><br><span class="line">“&lt;n&gt;;.s” 的目标的依赖目标会自动推导为“&lt;n&gt;;.S”，默认使用C预编译器“cpp”，并且其生成命令是：“<span class="variable">$(AS)</span> <span class="variable">$(ASFLAGS)</span>”。</span><br></pre></td></tr></table></figure>
<p>8、链接Object文件的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;”目标依赖于“&lt;n&gt;;.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“<span class="variable">$(CC)</span> <span class="variable">$(LDFLAGS)</span> &lt;n&gt;;.o <span class="variable">$(LOADLIBES)</span> <span class="variable">$(LDLIBS)</span>”。</span><br></pre></td></tr></table></figure>
<p>这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x : y.o z.o</span><br></pre></td></tr></table></figure>
<p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cc -c x.c -o x.o</span><br><span class="line">cc -c y.c -o y.o</span><br><span class="line">cc -c z.c -o z.o</span><br><span class="line">cc x.o y.o z.o -o x</span><br><span class="line">rm -f x.o</span><br><span class="line">rm -f y.o</span><br><span class="line">rm -f z.o</span><br></pre></td></tr></table></figure>
<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>
<p>9、Yacc C程序时的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“<span class="variable">$(YACC)</span> <span class="variable">$(YFALGS)</span>”。（“Yacc”是一个语法分析器）</span><br></pre></td></tr></table></figure>
<p>10、Lex C程序时的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“<span class="variable">$(LEX)</span> <span class="variable">$(LFALGS)</span>”。</span><br></pre></td></tr></table></figure>
<p>11、Lex Ratfor程序时的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“<span class="variable">$(LEX)</span> <span class="variable">$(LFALGS)</span>”。</span><br></pre></td></tr></table></figure>
<p>12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“&lt;n&gt;;.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“<span class="variable">$(LINT)</span> <span class="variable">$(LINTFALGS)</span> <span class="variable">$(CPPFLAGS)</span> -i”。</span><br><span class="line">对于“&lt;n&gt;;.y”和“&lt;n&gt;;.l”也是同样的规则。</span><br></pre></td></tr></table></figure>
<p>三、隐含规则使用的变量</p>
<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：</p>
<p>1、关于命令的变量。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">AR </span><br><span class="line">    函数库打包程序。默认命令是“ar”。 </span><br><span class="line">AS </span><br><span class="line">    汇编语言编译程序。默认命令是“as”。</span><br><span class="line">CC </span><br><span class="line">    C语言编译程序。默认命令是“cc”。</span><br><span class="line">CXX </span><br><span class="line">    C++语言编译程序。默认命令是“g++”。</span><br><span class="line">CO </span><br><span class="line">    从 RCS文件中扩展文件程序。默认命令是“co”。</span><br><span class="line">CPP </span><br><span class="line">    C程序的预处理器（输出是标准输出设备）。默认命令是“<span class="variable">$(CC)</span> –E”。</span><br><span class="line">FC </span><br><span class="line">    Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。</span><br><span class="line">GET </span><br><span class="line">    从SCCS文件中扩展文件的程序。默认命令是“get”。 </span><br><span class="line">LEX </span><br><span class="line">    Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。</span><br><span class="line">PC </span><br><span class="line">    Pascal语言编译程序。默认命令是“pc”。</span><br><span class="line">YACC </span><br><span class="line">    Yacc文法分析器（针对于C程序）。默认命令是“yacc”。</span><br><span class="line">YACCR </span><br><span class="line">    Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。</span><br><span class="line">MAKEINFO </span><br><span class="line">    转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。</span><br><span class="line">TEX </span><br><span class="line">    从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。</span><br><span class="line">TEXI2DVI </span><br><span class="line">    从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。</span><br><span class="line">WEAVE </span><br><span class="line">    转换Web到TeX的程序。默认命令是“weave”。</span><br><span class="line">CWEAVE </span><br><span class="line">    转换C Web 到 TeX的程序。默认命令是“cweave”。</span><br><span class="line">TANGLE </span><br><span class="line">    转换Web到Pascal语言的程序。默认命令是“tangle”。</span><br><span class="line">CTANGLE </span><br><span class="line">    转换C Web 到 C。默认命令是“ctangle”。</span><br><span class="line">RM </span><br><span class="line">    删除文件命令。默认命令是“rm –f”。</span><br></pre></td></tr></table></figure>
<p>2、关于命令参数的变量</p>
<p>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ARFLAGS </span><br><span class="line">    函数库打包程序AR命令的参数。默认值是“rv”。</span><br><span class="line">ASFLAGS </span><br><span class="line">    汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。 </span><br><span class="line">CFLAGS </span><br><span class="line">    C语言编译器参数。</span><br><span class="line">CXXFLAGS </span><br><span class="line">    C++语言编译器参数。</span><br><span class="line">COFLAGS </span><br><span class="line">    RCS命令参数。 </span><br><span class="line">CPPFLAGS </span><br><span class="line">    C预处理器参数。（ C 和 Fortran 编译器也会用到）。</span><br><span class="line">FFLAGS </span><br><span class="line">    Fortran语言编译器参数。</span><br><span class="line">GFLAGS </span><br><span class="line">    SCCS “get”程序参数。</span><br><span class="line">LDFLAGS </span><br><span class="line">    链接器参数。（如：“ld”）</span><br><span class="line">LFLAGS </span><br><span class="line">    Lex文法分析器参数。</span><br><span class="line">PFLAGS </span><br><span class="line">    Pascal语言编译器参数。</span><br><span class="line">RFLAGS </span><br><span class="line">    Ratfor 程序的Fortran 编译器参数。</span><br><span class="line">YFLAGS </span><br><span class="line">    Yacc文法分析器参数。</span><br></pre></td></tr></table></figure>
<p> 四、隐含规则链</p>
<p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则叫做“隐含规则链”。</p>
<p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p>
<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。</p>
<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）</p>
<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。</p>
<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>
<p>Make会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规则就不会生成中间文件。</p>
<p>五、定义模式规则</p>
<p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。</p>
<p>有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。</p>
<p>1、模式规则介绍</p>
<p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为5）。</p>
<p>2、模式规则示例</p>
<p>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o : %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>其中，”\$@”表示所有的目标的值，”$&lt;”表示了所有依赖目标的值。这些奇怪的变量我们叫”自动化变量”</p>
<p>3、自动化变量</p>
<p>自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span></span><br><span class="line"><span class="comment">#表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，"$@"就是匹配于目标中模式定义的集合。</span></span><br><span class="line"><span class="variable">$%</span></span><br><span class="line"><span class="comment">#仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是"foo.a(bar.o)"，那么，"$%"就是"bar.o"，"$@"就是"foo.a"。如果目标不是函数库文件（Unix下是[.a]，Windows下是[.lib]），那么，其值为空。</span></span><br><span class="line"><span class="variable">$&lt;</span></span><br><span class="line"><span class="comment">#依赖目标中的第一个目标名字。如果依赖目标是以模式（即"%"）定义的，那么"$&lt;"将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</span></span><br><span class="line"><span class="variable">$?</span></span><br><span class="line"><span class="comment">#所有比目标新的依赖目标的集合。以空格分隔。</span></span><br><span class="line"><span class="variable">$^</span></span><br><span class="line"><span class="comment">#所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</span></span><br><span class="line"><span class="variable">$+</span></span><br><span class="line"><span class="comment">#这个变量很像"​\$^"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/22/Makefile入门7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hey Z">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信头像.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hey Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/Makefile入门7/" itemprop="url">Makefile入门7</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T14:27:04+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="make的运行"><a href="#make的运行" class="headerlink" title="make的运行"></a><strong>make的运行</strong></h1><p>​        转自《跟我一起写Makefile》</p>
<p>​        <a href="https://seisman.github.io/how-to-write-makefile/index.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
<p>​        一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。</p>
<p>一、make的退出码</p>
<p>make命令执行后有三个退出码：</p>
<p>​    0 —— 表示成功执行。<br>​    1 —— 如果make运行时出现任何错误，其返回1。<br>​    2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。</p>
<p>二、指定Makefile</p>
<p>GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就开始读取这个文件并执行。</p>
<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“–file”参数（“–makefile”参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make –f hchen.mk</span><br></pre></td></tr></table></figure>
<p>如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>
<p>三、指定目标</p>
<p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）</p>
<p>任何在makefile中的目标都可以被指定成终极目标，但是除了以“-”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>
<p>有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：   </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">ifneq</span> ( <span class="variable">$(MAKECMDGOALS)</span>,clean)</span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">#只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</span></span><br></pre></td></tr></table></figure>
<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: all</span></span><br><span class="line"><span class="section">all: prog1 prog2 prog3 prog4</span></span><br></pre></td></tr></table></figure>
<p>在Unix世界中，软件发布时，特别是GNU这种开源软件的发布时，其makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#“all”</span></span><br><span class="line">	这个伪目标是所有目标的目标，其功能一般是编译所有的目标。</span><br><span class="line"><span class="comment">#“clean”</span></span><br><span class="line">	这个伪目标功能是删除所有被make创建的文件。</span><br><span class="line"><span class="comment">#“install”</span></span><br><span class="line">	这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。</span><br><span class="line"><span class="comment">#“print”</span></span><br><span class="line">	这个伪目标的功能是列出改变过的源文件。</span><br><span class="line"><span class="comment">#“tar”</span></span><br><span class="line">	这个伪目标功能是把源程序打包备份。也就是一个tar文件。</span><br><span class="line"><span class="comment">#“dist”</span></span><br><span class="line">	这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。</span><br><span class="line"><span class="comment">#“TAGS”</span></span><br><span class="line">	这个伪目标功能是更新所有的目标，以备完整地重编译使用。</span><br><span class="line"><span class="comment">#“check”和“test”</span></span><br><span class="line">	这两个伪目标一般用来测试makefile的流程。</span><br></pre></td></tr></table></figure>
<p>四、检查规则</p>
<p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“-n”</span><br><span class="line">“--just-print”</span><br><span class="line">“--dry-run”</span><br><span class="line">“--recon”</span><br><span class="line"><span class="comment">#不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-t”</span><br><span class="line">“--touch”</span><br><span class="line"><span class="comment">#这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-q”</span><br><span class="line">“--question”</span><br><span class="line"><span class="comment">#这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“-W &lt;file&gt;;”</span><br><span class="line">“--what-if=&lt;file&gt;;”</span><br><span class="line">“--assume-new=&lt;file&gt;;”</span><br><span class="line">“--new-file=&lt;file&gt;;”</span><br><span class="line"><span class="comment">#这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。</span></span><br></pre></td></tr></table></figure>
<p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息。</p>
<p>五、make的参数</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-b”</span><br><span class="line">“-m”</span><br><span class="line"><span class="comment">#这两个参数的作用是忽略和其它版本make的兼容性。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-B”</span><br><span class="line">“--always-make”</span><br><span class="line"><span class="comment">#认为所有的目标都需要更新（重编译）。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-C &lt;dir&gt;;”</span><br><span class="line">“--directory=&lt;dir&gt;;”</span><br><span class="line"><span class="comment">#指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”等价于“make –C ~hchen/test/prog”。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">“—debug[=&lt;options&gt;;]”</span><br><span class="line"><span class="comment">#输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是&lt;options&gt;;的取值：</span></span><br><span class="line">    a —— 也就是all，输出所有的调试信息。（会非常的多）</span><br><span class="line">    b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。</span><br><span class="line">    v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。</span><br><span class="line">    i —— 也就是implicit，输出所以的隐含规则。</span><br><span class="line">    j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。</span><br><span class="line">    m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“-d”</span><br><span class="line"><span class="comment">#相当于“--debug=a”。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-e”</span><br><span class="line">“--environment-overrides”</span><br><span class="line"><span class="comment">#指明环境变量的值覆盖makefile中定义的变量的值。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“-f=&lt;file&gt;;”</span><br><span class="line">“--file=&lt;file&gt;;”</span><br><span class="line">“--makefile=&lt;file&gt;;”</span><br><span class="line"><span class="comment">#指定需要执行的makefile。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-h”</span><br><span class="line">“--help”</span><br><span class="line"><span class="comment">#显示帮助信息。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-i”</span><br><span class="line">“--ignore-errors”</span><br><span class="line"><span class="comment">#在执行时忽略所有的错误。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-I &lt;dir&gt;;”</span><br><span class="line">“--include-dir=&lt;dir&gt;;”</span><br><span class="line"><span class="comment">#指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-j [&lt;jobsnum&gt;;]”</span><br><span class="line">“--jobs[=&lt;jobsnum&gt;;]”</span><br><span class="line"><span class="comment">#指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-DOS中是无用的）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-k”</span><br><span class="line">“--keep-going”</span><br><span class="line"><span class="comment">#出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“-l &lt;load&gt;;”</span><br><span class="line">“--load-average[=&lt;load]”</span><br><span class="line">“—max-load[=&lt;load&gt;;]”</span><br><span class="line"><span class="comment">#指定make运行命令的负载。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“-n”</span><br><span class="line">“--just-print”</span><br><span class="line">“--dry-run”</span><br><span class="line">“--recon”</span><br><span class="line"><span class="comment">#仅输出执行过程中的命令序列，但并不执行。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“-o &lt;file&gt;;”</span><br><span class="line">“--old-file=&lt;file&gt;;”</span><br><span class="line">“--assume-old=&lt;file&gt;;”</span><br><span class="line"><span class="comment">#不重新生成的指定的&lt;file&gt;;，即使这个目标的依赖文件新于它。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-p”</span><br><span class="line">“--print-data-base”</span><br><span class="line"><span class="comment">#输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行makefile，你可以使用“make -qp”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-q”</span><br><span class="line">“--question”</span><br><span class="line"><span class="comment">#不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-r”</span><br><span class="line">“--no-builtin-rules”</span><br><span class="line"><span class="comment">#禁止make使用任何隐含规则。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-R”</span><br><span class="line">“--no-builtin-variabes”</span><br><span class="line"><span class="comment">#禁止make使用任何作用于变量上的隐含规则。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“-s”</span><br><span class="line">“--silent”</span><br><span class="line">“--quiet”</span><br><span class="line"><span class="comment">#在命令运行时不输出命令的输出。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">“-S”</span><br><span class="line">“--no-keep-going”</span><br><span class="line">“--stop”</span><br><span class="line"><span class="comment">#取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-t”</span><br><span class="line">“--touch”</span><br><span class="line"><span class="comment">#相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-v”</span><br><span class="line">“--version”</span><br><span class="line"><span class="comment">#输出make程序的版本、版权等关于make的信息。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“-w”</span><br><span class="line">“--print-directory”</span><br><span class="line"><span class="comment">#输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“--no-print-directory”</span><br><span class="line"><span class="comment">#禁止“-w”选项。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">“-W &lt;file&gt;;”</span><br><span class="line">“--what-if=&lt;file&gt;;”</span><br><span class="line">“--new-file=&lt;file&gt;;”</span><br><span class="line">“--assume-file=&lt;file&gt;;”</span><br><span class="line"><span class="comment">#假定目标&lt;file&gt;;需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得&lt;file&gt;;的修改时间为当前时间。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“--warn-undefined-variables”</span><br><span class="line"><span class="comment">#只要make发现有未定义的变量，那么就输出警告信息。</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/22/Makefile入门6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hey Z">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信头像.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hey Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/Makefile入门6/" itemprop="url">Makefile入门6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T13:35:28+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Makefile判断和函数"><a href="#Makefile判断和函数" class="headerlink" title="Makefile判断和函数"></a><strong>Makefile判断和函数</strong></h1><p>​        转自《跟我一起写Makefile》</p>
<p>​        <a href="https://seisman.github.io/how-to-write-makefile/index.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
<p>​        使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>
<p>一、条件判断</p>
<p>1、下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">	<span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</p>
<p>2、语法</p>
<p>条件表达式的语法为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;;</span><br><span class="line">&lt;text-if-true&gt;;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>以及：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;;</span><br><span class="line">&lt;text-if-true&gt;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&lt;text-if-false&gt;;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>其中<conditional-directive>;表示条件关键字，如“ifeq”。这个关键字有四个：</conditional-directive></p>
<ol>
<li>第一个是我们前面所见过的“ifeq”，比较参数“arg1”和“arg2”的值是否相同；</li>
<li>第二个条件关键字是“ifneq”，其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真；</li>
<li>第三个条件关键字是“ifdef”，语法是： ifdef <variable-name>，如果变量<variable-name>;的值非空，那到表达式为真；</variable-name></variable-name></li>
<li>第四个条件关键字是“ifndef”，和“ifdef”是相反的意思。</li>
</ol>
<p>在<conditional-directive>;这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也一样，只要不是以[Tab]键开始就行了。</conditional-directive></p>
<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>
<p>二、使用函数</p>
<p>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</p>
<p>1、函数的调用语法</p>
<p>函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&lt;function&gt;; &lt;arguments&gt;;)</span><br><span class="line">或是</span><br><span class="line">$&#123;&lt;function&gt;; &lt;arguments&gt;;&#125;</span><br></pre></td></tr></table></figure>
<p><function>;就是函数名。<arguments>;是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。</arguments></function></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br></pre></td></tr></table></figure>
<p>2、字符串处理函数</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">subst</span> &lt;from&gt;;,&lt;to&gt;;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment">#名称：字符串替换函数——subst;</span></span><br><span class="line"><span class="comment">#功能：把字串&lt;text&gt;;中的&lt;from&gt;;字符串替换成&lt;to&gt;;</span></span><br><span class="line"><span class="comment">#返回：函数返回被替换过后的字符串;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> &lt;pattern&gt;;,&lt;replacement&gt;;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment">#名称：模式字符串替换函数——patsubst</span></span><br><span class="line"><span class="comment">#功能：查找&lt;text&gt;;中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式&lt;pattern&gt;;，如果匹配的话，则以&lt;replacement&gt;;替换。这里，&lt;pattern&gt;;可以包括通配符“%”，表示任意长度的字串。如果&lt;replacement&gt;;中也包含“%”，那么，&lt;replacement&gt;;中的这个“%”将是&lt;pattern&gt;;中的那个“%”所代表的字串。（可以用“\”来转义，以“\%”来表示真实含义的“%”字符）</span></span><br><span class="line"><span class="comment">#返回：函数返回被替换过后的字符串。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">strip</span> &lt;string&gt;)</span></span><br><span class="line"><span class="comment">#名称：去空格函数——strip。</span></span><br><span class="line"><span class="comment">#功能：去掉&lt;string&gt;;字串中开头和结尾的空字符。</span></span><br><span class="line"><span class="comment">#返回：返回被去掉空格的字符串值。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">findstring</span> &lt;find&gt;;,&lt;in&gt;)</span></span><br><span class="line"><span class="comment">#名称：查找字符串函数——findstring。</span></span><br><span class="line"><span class="comment">#功能：在字串&lt;in&gt;;中查找&lt;find&gt;;字串。</span></span><br><span class="line"><span class="comment">#返回：如果找到，那么返回&lt;find&gt;;，否则返回空字符串。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span> &lt;pattern...&gt;;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment">#名称：过滤函数——filter。</span></span><br><span class="line"><span class="comment">#功能：以&lt;pattern&gt;;模式过滤&lt;text&gt;;字符串中的单词，保留符合模式&lt;pattern&gt;;的单词。可以有多个模式。</span></span><br><span class="line"><span class="comment">#返回：返回符合模式&lt;pattern&gt;;的字串。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">filter</span>-out &lt;pattern...&gt;;,&lt;text&gt;)</span></span><br><span class="line"><span class="comment">#名称：反过滤函数——filter-out。</span></span><br><span class="line"><span class="comment">#功能：以&lt;pattern&gt;;模式过滤&lt;text&gt;;字符串中的单词，去除符合模式&lt;pattern&gt;;的单词。可以有多个模式。</span></span><br><span class="line"><span class="comment">#返回：返回不符合模式&lt;pattern&gt;;的字串。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">sort</span> &lt;list&gt;)</span></span><br><span class="line"><span class="comment">#名称：排序函数——sort。</span></span><br><span class="line"><span class="comment">#功能：给字符串&lt;list&gt;;中的单词排序（升序）。</span></span><br><span class="line"><span class="comment">#返回：返回排序后的字符串。</span></span><br><span class="line"><span class="comment">#备注：sort函数会去掉&lt;list&gt;;中相同的单词。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">word</span> &lt;n&gt;;,&lt;text&gt;;)</span></span><br><span class="line"><span class="comment">#名称：取单词函数——word。</span></span><br><span class="line"><span class="comment">#功能：取字符串&lt;text&gt;;中第&lt;n&gt;;个单词。（从一开始）</span></span><br><span class="line"><span class="comment">#返回：返回字符串&lt;text&gt;;中第&lt;n&gt;;个单词。如果&lt;n&gt;;比&lt;text&gt;;中的单词数要大，那么返回空字符串。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">wordlist</span> &lt;s&gt;;,&lt;e&gt;;,&lt;text&gt;;)</span>  </span><br><span class="line"><span class="comment">#名称：取单词串函数——wordlist。</span></span><br><span class="line"><span class="comment">#功能：从字符串&lt;text&gt;;中取从&lt;s&gt;;开始到&lt;e&gt;;的单词串。&lt;s&gt;;和&lt;e&gt;;是一个数字。</span></span><br><span class="line"><span class="comment">#返回：返回字符串&lt;text&gt;;中从&lt;s&gt;;到&lt;e&gt;;的单词字串。如果&lt;s&gt;;比&lt;text&gt;;中的单词数要大，那么返回空字符串。如果&lt;e&gt;;大于&lt;text&gt;;的单词数，那么返回从&lt;s&gt;;开始，到&lt;text&gt;;结束的单词串。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(words &lt;text&gt;;)</span></span><br><span class="line"><span class="comment">#名称：单词个数统计函数——words。</span></span><br><span class="line"><span class="comment">#功能：统计&lt;text&gt;;中字符串中的单词个数。</span></span><br><span class="line"><span class="comment">#返回：返回&lt;text&gt;;中的单词数。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">firstword</span> &lt;text&gt;;)</span></span><br><span class="line"><span class="comment">#名称：首单词函数——firstword。</span></span><br><span class="line"><span class="comment">#功能：取字符串&lt;text&gt;;中的第一个单词。</span></span><br><span class="line"><span class="comment">#返回：返回字符串&lt;text&gt;;的第一个单词。</span></span><br></pre></td></tr></table></figure>
<p>举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> CFLAGS += <span class="variable">$(<span class="built_in">patsubst</span> %,-I%,$(<span class="built_in">subst</span> :, ,<span class="variable">$(VPATH)</span>)</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们的“\$(VPATH)”值是“src:../headers”，那么“\$(patsubst %,-I%,​\$(subst :, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数。</p>
<p>3、文件名操作函数</p>
<p>每个函数的参数字符串都会被当做一个或是一系列的文件名来对待。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">dir</span> &lt;names...&gt;;)</span> </span><br><span class="line"><span class="comment">#名称：取目录函数——dir。</span></span><br><span class="line"><span class="comment">#功能：从文件名序列&lt;names&gt;;中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。</span></span><br><span class="line"><span class="comment">#返回：返回文件名序列&lt;names&gt;;的目录部分。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">notdir</span> &lt;names...&gt;;)</span> </span><br><span class="line"><span class="comment">#名称：取文件函数——notdir。</span></span><br><span class="line"><span class="comment">#功能：从文件名序列&lt;names&gt;;中取出非目录部分。非目录部分是指最后一个反斜杠（“/”）之后的部分。</span></span><br><span class="line"><span class="comment">#返回：返回文件名序列&lt;names&gt;;的非目录部分。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">suffix</span> &lt;names...&gt;;)</span></span><br><span class="line"><span class="comment">#名称：取后缀函数——suffix。</span></span><br><span class="line"><span class="comment">#功能：从文件名序列&lt;names&gt;;中取出各个文件名的后缀。</span></span><br><span class="line"><span class="comment">#返回：返回文件名序列&lt;names&gt;;的后缀序列，如果文件没有后缀，则返回空字串。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">basename</span> &lt;names...&gt;;)</span></span><br><span class="line"><span class="comment">#名称：取前缀函数——basename。</span></span><br><span class="line"><span class="comment">#功能：从文件名序列&lt;names&gt;;中取出各个文件名的前缀部分。</span></span><br><span class="line"><span class="comment">#返回：返回文件名序列&lt;names&gt;;的前缀序列，如果文件没有前缀，则返回空字串。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addsuffix</span> &lt;<span class="built_in">suffix</span>&gt;;,&lt;names...&gt;;)</span> </span><br><span class="line"><span class="comment">#名称：加后缀函数——addsuffix。</span></span><br><span class="line"><span class="comment">#功能：把后缀&lt;suffix&gt;;加到&lt;names&gt;;中的每个单词后面。</span></span><br><span class="line"><span class="comment">#返回：返回加过后缀的文件名序列。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">addprefix</span> &lt;prefix&gt;;,&lt;names...&gt;;)</span> </span><br><span class="line"><span class="comment">#名称：加前缀函数——addprefix。</span></span><br><span class="line"><span class="comment">#功能：把前缀&lt;prefix&gt;;加到&lt;names&gt;;中的每个单词后面。</span></span><br><span class="line"><span class="comment">#返回：返回加过前缀的文件名序列。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">join</span> &lt;list1&gt;;,&lt;list2&gt;;)</span></span><br><span class="line"><span class="comment">#名称：连接函数——join。</span></span><br><span class="line"><span class="comment">#功能：把&lt;list2&gt;;中的单词对应地加到&lt;list1&gt;;的单词后面。如果&lt;list1&gt;;的单词个数要比&lt;list2&gt;;的多，那么，&lt;list1&gt;;中的多出来的单词将保持原样。如果&lt;list2&gt;;的单词个数要比&lt;list1&gt;;多，那么，&lt;list2&gt;;多出来的单词将被复制到&lt;list2&gt;;中。</span></span><br><span class="line"><span class="comment">#返回：返回连接过后的字符串。</span></span><br></pre></td></tr></table></figure>
<p>4、foreach函数</p>
<p>foreach函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的foreach函数几乎是仿照于Unix标准Shell（/bin/sh）中的for语句，或是C-Shell（/bin/csh）中的foreach语句而构建的。它的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;;,&lt;list&gt;;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>这个函数的意思是，把参数<list>;中的单词逐一取出放到参数<var>;所指定的变量中，然后再执行<text>;所包含的表达式。每一次<text>;会返回一个字符串，循环过程中，<text>;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。所以，<var>;最好是一个变量名，<list>;可以是一个表达式，而<text>;中一般会使用<var>;这个参数来依次枚举<list>;中的单词。举个例子：</list></var></text></list></var></text></text></text></text></var></list></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> n,<span class="variable">$(names)</span>,<span class="variable">$(n)</span>.o)</span></span><br></pre></td></tr></table></figure>
<p>注意，foreach中的<var>;参数是一个临时的局部变量，foreach函数执行完后，参数<var>;的变量将不在作用，其作用域只在foreach函数当中。</var></var></p>
<p>5、if函数</p>
<p>if函数很像GNU的make所支持的条件语句——ifeq，if函数的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;;,&lt;then-part&gt;)</span></span><br><span class="line">或是</span><br><span class="line"><span class="variable">$(<span class="built_in">if</span> &lt;condition&gt;;,&lt;then-part&gt;;,&lt;else-part&gt;)</span></span><br></pre></td></tr></table></figure>
<p>6、call函数</p>
<p>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">call</span> &lt;expression&gt;;,&lt;parm1&gt;;,&lt;parm2&gt;;,&lt;parm3&gt;;...)</span></span><br></pre></td></tr></table></figure>
<p>当make执行这个函数时，<expression>;参数中的变量，如\$(1)，​\$(2)，$(3)等，会被参数<parm1>;，<parm2>;，<parm3>;依次取代。而<expression>;的返回值就是call函数的返回值。</expression></parm3></parm2></parm1></expression></p>
<p>7、origin函数</p>
<p>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">origin</span> &lt;variable&gt;)</span></span><br></pre></td></tr></table></figure>
<p>8、shell函数</p>
<p>shell函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br><span class="line">files := <span class="variable">$(<span class="built_in">shell</span> echo *.c)</span></span><br></pre></td></tr></table></figure>
<p>9、控制make的函数</p>
<p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">error</span> &lt;text …&gt;)</span></span><br></pre></td></tr></table></figure>
<p>产生一个致命的错误，<text ...>;是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。例如：</text></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例一，会在变量ERROR_001定义了后执行时产生error调用</span></span><br><span class="line"><span class="keyword">ifdef</span> ERROR_001</span><br><span class="line">	<span class="variable">$(<span class="built_in">error</span> <span class="built_in">error</span> is <span class="variable">$(ERROR_001)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">#示例二，在目录err被执行时才发生error调用</span></span><br><span class="line">ERR = <span class="variable">$(<span class="built_in">error</span> found an <span class="built_in">error</span>!)</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: err</span></span><br><span class="line"><span class="section">err: ; <span class="variable">$(ERR)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">warning</span> &lt;text ...&gt;)</span></span><br><span class="line"><span class="comment">#这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/Makefile入门5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hey Z">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信头像.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hey Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/Makefile入门5/" itemprop="url">Makefile入门5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T23:44:02+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Makefile变量"><a href="#Makefile变量" class="headerlink" title="Makefile变量"></a><strong>Makefile变量</strong></h1><p>​        转自《跟我一起写Makefile》</p>
<p>​        <a href="https://seisman.github.io/how-to-write-makefile/index.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
<p>​        在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是Makefile的其它部分中。</p>
<p>​        变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。</p>
<p>​        有一些变量是很奇怪字串，如“$&lt;”、“$@”等，这些是自动化变量。</p>
<p>一、变量基础</p>
<p>变量在声明时需要给予初值，而在使用时，需要给在变量名前加上“\$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“​\$”字符，那么你需要用“$$”来表示。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objects = program.o foo.o utils.o</span><br><span class="line">program : <span class="variable">$(objects)</span></span><br><span class="line">	cc -o program <span class="variable">$(objects)</span></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br></pre></td></tr></table></figure>
<p>二、变量中的变量</p>
<p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。</p>
<p>​    1、简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以    定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，    其也可以使用后面定义的值。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line">bar = <span class="variable">$(ugh)</span></span><br><span class="line">ugh = Huh?</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>
<p>​    2、使用“:=”操作符，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>
<p>​    其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y := foo bar</span><br><span class="line">x := later</span><br></pre></td></tr></table></figure>
<p>​    如果是这样：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := foo</span><br></pre></td></tr></table></figure>
<p>​    那么，y的值是“bar”，而不是“foo bar”。</p>
<p>如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure>
<p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir := /foo/bar    <span class="comment"># directory to put the frobs in</span></span><br></pre></td></tr></table></figure>
<p>dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。</p>
<p>还有一个比较有用的操作符是“?=”，先看示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOO ?= bar</span><br></pre></td></tr></table></figure>
<p>其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">origin</span> FOO)</span>, undefined)</span><br><span class="line">	FOO = bar</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>
<p>三、变量高级用法</p>
<p>1、变量值的替换</p>
<p>我们可以替换变量中的共有的部分，其格式是“\$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure>
<p>另外一种变量替换的技术是以“静态模式”定义的，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br></pre></td></tr></table></figure>
<p>2、把变量的值再当成变量</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注意，是“x=y”，而不是“x=$(y)”）</span></span><br><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>
<p>让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：   </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="variable">$(y)</span></span><br><span class="line">y = z</span><br><span class="line">z = Hello</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure>
<p>再复杂一点，我们再加上函数：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = variable1</span><br><span class="line">variable2 := Hello</span><br><span class="line">y = <span class="variable">$(<span class="built_in">subst</span> 1,2,<span class="variable">$(x)</span>)</span></span><br><span class="line">z = y</span><br><span class="line">a := $($(<span class="variable">$(z)</span>))</span><br></pre></td></tr></table></figure>
<p>这个例子中，“\$(\$(\$(z)))”扩展为“\$(\$(y))”，而其再次被扩展为“\$(\$(subst 1,2,\$(x)))”。\$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，\$(a)的值就是\$(variable2)的值——“Hello”。</p>
<p>四、追加变量值</p>
<p>我们可以使用“+=”操作符给变量追加值，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o foo.o bar.o utils.o</span><br><span class="line">objects += another.o</span><br></pre></td></tr></table></figure>
<p>五、override指示符</p>
<p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> &lt;variable&gt;; = &lt;value&gt;;</span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt;; := &lt;value&gt;;</span><br></pre></td></tr></table></figure>
<p>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> foo</span><br><span class="line">bar</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>六、多行变量</p>
<p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令。define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p>
<p>下面的这个示例展示了define的用法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>七、环境变量</p>
<p>make运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）。</p>
<p>因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。</p>
<p>当make嵌套调用时，上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层Makefile传递，则需要使用exprot关键字来声明。</p>
<p>八、目标变量</p>
<p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>
<p>当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>
<p>其语法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target ...&gt;; : &lt;variable-assignment&gt;;</span><br><span class="line">&lt;target ...&gt;; : overide &lt;variable-assignment&gt;;</span><br></pre></td></tr></table></figure>
<p><variable-assignment>;可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</variable-assignment></p>
<p>当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p>
<p>​    </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br><span class="line"></span><br><span class="line">prog.o : prog.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.c</span><br><span class="line"></span><br><span class="line">foo.o : foo.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> foo.c</span><br><span class="line"></span><br><span class="line">bar.o : bar.c</span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> bar.c</span><br></pre></td></tr></table></figure>
<p>在这个示例中，不管全局的\$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”。</p>
<p>九、模式变量</p>
<p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>
<p>我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%.o : CFLAGS = -O</span><br></pre></td></tr></table></figure>
<p>同样，模式变量的语法和“目标变量”一样：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pattern ...&gt;; : &lt;variable-assignment&gt;;</span><br><span class="line">&lt;pattern ...&gt;; : <span class="keyword">override</span> &lt;variable-assignment&gt;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/Makefile入门4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hey Z">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信头像.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hey Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/Makefile入门4/" itemprop="url">Makefile入门4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T23:24:55+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Makefile命令"><a href="#Makefile命令" class="headerlink" title="Makefile命令"></a><strong>Makefile命令</strong></h1><p>​        转自《跟我一起写Makefile》</p>
<p>​        <a href="https://seisman.github.io/how-to-write-makefile/index.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
<p>​        每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p>
<p>一、显示命令</p>
<p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“@”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br></pre></td></tr></table></figure>
<p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 正在编译XXX模块......</span><br><span class="line">正在编译XXX模块......</span><br></pre></td></tr></table></figure>
<p>如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，而make参数“-s”或“–slient”则是全面禁止命令的显示。</p>
<p>二、命令执行</p>
<p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">	cd /home/hchen; pwd</span><br></pre></td></tr></table></figure>
<p>make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。</p>
<p>三、命令出错</p>
<p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>
<p>为了忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -f *.o</span><br></pre></td></tr></table></figure>
<p>还有一个全局的办法是，给make加上“-i”或是“–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。</p>
<p>make的参数“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p>
<p>四、嵌套执行make</p>
<p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>
<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>
<p>定义\$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。</p>
<p>我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。</p>
<p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &lt;variable ...&gt;;</span><br></pre></td></tr></table></figure>
<p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明： </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unexport</span> &lt;variable ...&gt;;</span><br></pre></td></tr></table></figure>
<p>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</p>
<p>需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p>
<p>但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”。如果你不想往下层传递参数，那么，你可以这样来：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure>
<p>五、定义命令包</p>
<p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。</p>
<p>要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”，make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.c : foo.y</span><br><span class="line">	$(run-yacc)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/21/Makefile入门3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hey Z">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信头像.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hey Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/Makefile入门3/" itemprop="url">Makefile入门3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-21T22:04:15+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Makefile规则和多目标"><a href="#Makefile规则和多目标" class="headerlink" title="Makefile规则和多目标"></a><strong>Makefile规则和多目标</strong></h1><p>转自《跟我一起写Makefile》</p>
<p><a href="https://seisman.github.io/how-to-write-makefile/index.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
<p>一、Makefile书写规则</p>
<p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p>
<p>在Makefile中，规则的顺序是很重要的，因为，Makefile中只应该有一个最终目标，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</p>
<p>1、规则举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c defs.h       # foo模块</span><br><span class="line">	cc -c -g foo.c           # tab开头</span><br></pre></td></tr></table></figure>
<p>foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令“cc -c -g foo.c”（以Tab键开头）。这个规则告诉我们两件事：</p>
<p>​    1、文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。<br>​    2、如何生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）</p>
<p>2、规则语法</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">	command</span><br><span class="line">	...</span><br><span class="line">        </span><br><span class="line">targets : prerequisites ; command</span><br><span class="line">	command</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。</p>
<p>3、规则中使用通配符</p>
<p>如果我们想定义一系列比较类似的文件，可以使用通配符。make支持三各通配符：“*”，“?”和“[…]”</p>
<p>波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。</p>
<p>通配符代替了你一系列的文件，如“<em>.c”表示所以后缀为c的文件。如果我们的文件名中有通配符，如：“</em>”，那么可以用转义字符“\”，如“\*<em>”来表示真实的“</em>”字符。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects = *.o</span><br></pre></td></tr></table></figure>
<p>通符同样可以用在变量中。并不是说[<em>.o]会展开，而是objects的值就是“</em>.o”。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样，这种用法由关键字“wildcard”指出：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br></pre></td></tr></table></figure>
<p>4、文件搜寻</p>
<p>当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p>
<p>​    1). Makefile文件中的特殊变量“VPATH”完成自动寻找文件的功能，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>
<p>上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当前目录在最高优先级）</p>
<p>​    2). 另一个设置文件搜索路径的方法是使用make的“vpath”关键字（全小写，make关键字，和VPATH类似，但更灵活），它可以指定不同的文件在不同的搜索目录中。使用方法有三种：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、vpath &lt;pattern&gt;; &lt;directories&gt;;</span><br><span class="line"></span><br><span class="line">为符合模式&lt;pattern&gt;;的文件指定搜索目录&lt;directories&gt;;。</span><br><span class="line"></span><br><span class="line">2、vpath &lt;pattern&gt;;</span><br><span class="line"></span><br><span class="line">清除符合模式&lt;pattern&gt;;的文件的搜索目录。</span><br><span class="line"></span><br><span class="line">3、vpath</span><br><span class="line"></span><br><span class="line">清除所有已被设置好了的文件搜索目录。</span><br></pre></td></tr></table></figure>
<p>vapth使用方法中的<pattern>;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。<pattern>;指定了要搜索的文件集，而<directories>;则指定了<pattern>;的文件集的搜索的目录。例如：</pattern></directories></pattern></pattern></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br><span class="line"><span class="comment"># 要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）</span></span><br></pre></td></tr></table></figure>
<p>可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的<pattern>;，或是被重复了的<pattern>;，那么，make会按照vpath语句的先后顺序来执行搜索。如：</pattern></pattern></p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br><span class="line"><span class="keyword">vpath</span> %.c bar</span><br><span class="line"><span class="comment">#表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo:bar</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br><span class="line"><span class="comment"># 表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</span></span><br></pre></td></tr></table></figure>
<p>5、伪目标</p>
<p>“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。只有通过显示地指明这个“目标”才能让其生效。“伪目标”的取名不能和文件名重名。可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪目标clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o temp</span><br><span class="line"><span class="comment"># 显式指定伪目标，只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样</span></span><br><span class="line">.PHONY : clean</span><br><span class="line">	rm *.o temp</span><br></pre></td></tr></table></figure>
<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。例如，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile中的第一个目标会被作为其默认目标</span></span><br><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">	cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">	cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">	cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>
<p>二、多目标</p>
<p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。可以使用自动化变量“$@”，表示着目前规则中所有的目标的集合</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">	generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt;; <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述规则等价于：</span></span><br><span class="line">bigoutput : text.g</span><br><span class="line">	generate text.g -big &gt;; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">	generate text.g -little &gt;; littleoutput</span><br></pre></td></tr></table></figure>
<p>其中，-\$(subst output,,\$$@)中的“$\$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。</p>
<p>三、静态模式</p>
<p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets ...&gt;;: &lt;target-pattern&gt;;: &lt;prereq-patterns ...&gt;;</span><br><span class="line">	&lt;commands&gt;;</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>具体例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中，指明了我们的目标从\$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量\$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foo bar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.c bar.c”。而命令中的“\$&lt;”和“\$@”则是自动化变量，“\$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>
<p>再看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">files = foo.elc bar.o lose.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(files)</span>)</span>: %.o: %.c</span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.elc,<span class="variable">$(files)</span>)</span>: %.elc: %.el</span><br><span class="line">	emacs -f batch-byte-compile <span class="variable">$&lt;</span></span><br></pre></td></tr></table></figure>
<p>\$(filter %.o,​\$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。</p>
<p>四、自动生成依赖</p>
<p>大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们的main.c中有一句“#include “defs.h””，执行下面的命令：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -M main.c</span><br></pre></td></tr></table></figure>
<p>其输出是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。</p>
<p>gcc -M main.c的输出是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o: main.c defs.h /usr/include/stdio.h 				      </span></span><br><span class="line">		/usr/<span class="keyword">include</span>/features.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/sys/cdefs.h /usr/<span class="keyword">include</span>/gnu/stubs.h \</span><br><span class="line">    /usr/lib/gcc-lib/i486-suse-		    </span><br><span class="line">    			linux/2.95.3/<span class="keyword">include</span>/stddef.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/types.h 	</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/pthreadtypes.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/sched.h /usr/<span class="keyword">include</span>/libio.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/_G_config.h /usr/<span class="keyword">include</span>/wchar.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/wchar.h /usr/<span class="keyword">include</span>/gconv.h \</span><br><span class="line">    /usr/lib/gcc-lib/i486-suse-</span><br><span class="line">    			linux/2.95.3/<span class="keyword">include</span>/stdarg.h \</span><br><span class="line">    /usr/<span class="keyword">include</span>/bits/stdio_lim.h</span><br></pre></td></tr></table></figure>
<p>​    gcc -MM main.c的输出则是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o: main.c defs.h</span></span><br></pre></td></tr></table></figure>
<p>GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或生成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p>
<p>这里，我们给出了一个模式规则来产生[.d]文件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%.d: %.c</span></span><br><span class="line">	@set -e; rm -f <span class="variable">$@</span>; \</span><br><span class="line">	<span class="variable">$(CC)</span> -M <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> &gt;; <span class="variable">$@</span>.$$$$; \</span><br><span class="line">	sed 's,\(<span class="variable">$*</span>\)\.o[ :]*,\1.o <span class="variable">$@</span> : ,g' &lt; <span class="variable">$@</span>.$$$$ &gt;; <span class="variable">$@</span>; \</span><br><span class="line">	rm -f <span class="variable">$@</span>.$$$$</span><br></pre></td></tr></table></figure>
<p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm -f \$@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“​\$&lt;”，也就是[.c]文件生成依赖文件，“\$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，“$$$$”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，第四行就是删除临时文件。总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>转成：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o main.d : main.c defs.h</span><br></pre></td></tr></table></figure>
<p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sources = foo.c bar.c</span><br><span class="line"><span class="keyword">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>
<p>上述语句中的“\$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]。因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/20/Makefile入门2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hey Z">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信头像.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hey Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/Makefile入门2/" itemprop="url">Makefile入门2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T15:10:45+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Makefile基础"><a href="#Makefile基础" class="headerlink" title="Makefile基础"></a><strong>Makefile基础</strong></h1><p>转自《跟我一起写Makefile》</p>
<p><a href="https://seisman.github.io/how-to-write-makefile/index.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
<p>一、Makefile基础</p>
<p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>
<p>1、显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</p>
<p>2、隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</p>
<p>3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p>
<p>4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</p>
<p>5、注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。</p>
<p>最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。</p>
<p>二、Makefile文件名</p>
<p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p>
<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“–file”参数，如：make -f Make.Linux或make –file Make.AIX。</p>
<p>三、引用其他的Makefile</p>
<p>在Makefile使用include关键字可以把别的Makefile包含进来，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> &lt;filename&gt;;</span><br></pre></td></tr></table></figure>
<p>filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符），在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和<filename>;可以用一个或多个空格隔开。</filename></p>
<p>如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>
<p>​    1、如果make执行时，有“-I”或“–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。<br>​    2、如果目录<prefix>;/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</prefix></p>
<p>如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> &lt;filename&gt;;</span><br></pre></td></tr></table></figure>
<p>四、环境变量Makefiles</p>
<p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。</p>
<p>这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>
<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响</p>
<p>五、make的工作方式</p>
<p>GNU的make工作时的执行步骤入下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stage1:</span><br><span class="line">1、读入所有的Makefile。</span><br><span class="line">2、读入被include的其它Makefile。</span><br><span class="line">3、初始化文件中的变量。</span><br><span class="line">4、推导隐晦规则，并分析所有规则。</span><br><span class="line">5、为所有的目标文件创建依赖关系链。</span><br><span class="line">stage2:</span><br><span class="line">6、根据依赖关系，决定哪些目标要重新生成。</span><br><span class="line">7、执行生成命令。</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/20/Makefile入门1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hey Z">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信头像.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hey Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/Makefile入门1/" itemprop="url">Makefile入门1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-20T10:17:56+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Makefile简介"><a href="#Makefile简介" class="headerlink" title="Makefile简介"></a><strong>Makefile简介</strong></h1><p>转自《跟我一起写Makefile》</p>
<p><a href="https://seisman.github.io/how-to-write-makefile/index.html" target="_blank" rel="noopener">https://seisman.github.io/how-to-write-makefile/index.html</a></p>
<p>一、前言</p>
<p>Makefile是和make（解释makefile中指令的工具）命令一起配合使用的，关系到整个工程的编译规则。Makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译等等。</p>
<p>源文件—(编译compile)–&gt;中间目标文件object file（.obj/Windows，.o/UNIX）—(链接link)–&gt;执行文件。</p>
<p>编译时，编译器只检测程序语法，函数和变量是否被声明；需要告诉编译器头文件的所在位置（头文件中只声明，定义放在c/c++文件中），只要语法正确就可以编译出中间目标文件。通常，每个源文件对应一个中间目标文件（.o/.obj）。</p>
<p>链接时，主要是链接函数和全局变量；链接器会在所有的object file中找寻函数实现，（需要指定函数的object file）；通常给中间目标文件打包（库文件Library File(.lib/Windows)，Archive File(.a/UNIX)）</p>
<p>二、Makefile简介</p>
<p>make命令执行时，需要Makefile文件来告诉make怎样去编译和链接程序。</p>
<p>1、编写Makefile的规则：</p>
<p>​    1）如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。<br>​    2）如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。<br>​    3）如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</p>
<p>2、Makefile的写法：</p>
<p>​        target … : prerequisites …<br>​                    command<br>​                    …<br>​                    …</p>
<p>​    1）target是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label）；<br>​    2）prerequisites就是，要生成那个target所需要的文件或是目标；<br>​    3）command也就是make需要执行的命令（任意的Shell命令）；</p>
<p>​    prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行！</p>
<p>如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line">		cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">          insert.o search.o files.o utils.o</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">   	cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit main.o kbd.o command.o display.o \</span><br><span class="line">       insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p>
<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>
<p>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。(命令——“make clean”，以此来清除所有的目标文件，以便重编译。)</p>
<p>3、Makefile工作原理</p>
<p>​    1)、make会在当前目录下找名字叫“Makefile”或“makefile”的文件。<br>​    2)、如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。<br>​    3)、如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。<br>​    4)、如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）<br>​    5)、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是执行文件edit了。    </p>
<p>4、Makefile中使用变量</p>
<p>为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串。在makefile一开始就这样定义：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">              insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>以“$(objects)”的方式来使用这个变量。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">              insert.o search.o files.o utils.o</span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">		cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">   	cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit (objects)</span><br></pre></td></tr></table></figure>
<p>5、Makefile自动推导</p>
<p>make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">              insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">		cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">		rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>6、清空目标文件的规则</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">            rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">       clean :</span><br><span class="line">               -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>
<p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，不成文的规矩是——“clean从来都是放在文件的最后”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/15/Shell脚本编程6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hey Z">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信头像.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hey Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/Shell脚本编程6/" itemprop="url">Shell脚本编程6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T10:20:36+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Shell/" itemprop="url" rel="index">
                    <span itemprop="name">Shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>摘自《菜鸟教程》–<a href="https://www.runoob.com/linux/linux-shell.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-shell.html</a></p>
<p>1、  ./脚本名，子进程中运行脚本；</p>
<p>​        source 脚本名或. ./脚本名，本进程中运行脚本；</p>
<p>2、sh (Bourne shell)，最初使用，在shell编程方面优秀，但在用户交互方面欠缺；</p>
<p>​        bash (Bourne again shell)，向后兼容sh，在sh基础上增加增强了很多特性；</p>
<p>​        dash (Debian Almquist Shell)，比bash小的多，符合POSIX标准，Ubuntu默认；Linux下默认的 sh指向dash；</p>
<p>​        标记为#!/bin/sh的脚本不应使用任何POSIX没有规定的特性（如let等命令，但#!/bin/bash可以）</p>
<p>3、shell什么情况下会产生子进程</p>
<p>​        &amp;，提交后台作业；</p>
<p>​        管道；</p>
<p>​        括号命令列表，()操作符；</p>
<p>​        执行外部脚本程序；</p>
<p>4、shell不创建子程序的进程创建方式</p>
<p>​        source命令，脚本结束后返回当前进程；exec命令，脚本结束后退出当前shell进程；</p>
<p>5、作为子进程，其进程环境与父进程的环境是独立的，所以在变量传递过程中，需要注意子进程内部不能更改到父进程的变量。</p>
<p>一个shell中的系统环境变量会被复制到子shell中（用export定义的变量，即export的变量能被子进程引用；一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失（并不能返回到父shell中）；不用export定义的变量只对该shell有效，对子shell也是无效的。</p>
<p>6、bash shell用一个称作”环境变量”的特性来存储有关shell会话和工作环境的信息，它允许你在内存中存储数据，以便运行在shell上的程序和脚本访问，这些数据可以用来识别用户、账户、系统、shell特性以及任何其他你需要存储的数据。</p>
<p>shell中的环境变量有全局环境变量和局部环境变量，通过KV(variable=value)的形式声明一个局部变量，export这个局部变量则升级成为全局环境变量。</p>
<p>全局环境变量：在当前shell进程及子shell进程中可用（父shell进程全局环境变量的一个copy，子shell进程增、删、改、查对父shell进程的全局环境变量均无影响），父shell进程中不可用。</p>
<p>局部环境变量：当前shell进程可用，父子shell 进程不可用。</p>
<p>环境变量存在内存当中，断电后消失，如果想在下一次系统加电后还可以访问：</p>
<p>a.如果此变量是系统级别的（所有用户共享），则可以在/etc/profile中export；</p>
<p>b.如果此变量只对当前用户有效，则可以在~/.bash_profile(或者~./bash_login，或者~./profile，或者~./bashrc，或者/etc/bashrc中export).</p>
<p>7、启动shell，向用户提供了一组和linux kernel交互的接口。登陆shell可理解为后续交互shell和非交互shell的顶级父shell。</p>
<p>​        系统启动后的第一个进程是init，他会进行系统初始化并打开命令行终端，建立命令行所必须的stdin、stdout、stderr，这时用户才能进行系统登陆。当用户输入用户名时（启动shell会fork一个登陆shell进程），/bin/login程序会验证输入的用户名是否存在在/etc/passwd中，若存在，则继续在/etc/shadow中验证你输入的密码。验证通过，/bin/login程序会提取/etc/passwd中和用户相关的HOME、LOGNAME、SHELL、USER等变量来定义一个工作环境，此时/etc/passwd会执行最后一项，也就是用户默认的shell，此shell即为登陆shell的来源。</p>
<p>​        登陆shell首先会到/etc/profile中读取命令并执行，主要做两件事：定义并声明全局的环境变量，export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL，所有的shell进程都可以访问这些变量；到/etc/profile.d目录中执行该目录下的应用启动文件，这些应用随系统而启动，譬如vim、less等；到这两步时不同用户printenv的结果是一样的，然后登陆shell（顶级环境，入口~/.bash_profile）会在各个用户目录下执行一系列的个性化操作得到最终的登陆shell（用户shell进程，不同的用户有不同的shell进程环境）；命令行界面实际上是在登陆shell的环境中执行，输入bash启动的交互shell是登陆shell fork的一个子进程，交互式shell启动第一步检查当前用户的主目录下是否有.bashrc文件（声明局部变量和个性化配置），存在则读取并执行文件中的指令（定义别名、source /etc/bashrc（定义了用户的局部变量）、/etc/profile.d），所以开启一个交互式shell最初和登陆shell环境一样，且交互式shell的操作不会影响到父shell环境！非交互shell即是执行shell脚本，非交互shell作为交互shell fork出来的子进程，要想对非交互shell进行个性化，系统提供的”接口”为环境变量BASH_ENV，当启动一个非交互式shell时，系统会检查这个环境变量来查看要加载执行的启动文件，因此你可以自定义一个文件路径然后export BASH_ENV。</p>
<p>8、fork、source、exec</p>
<p>在一个脚本中调用其他脚本有三种方式：fork、source、exec</p>
<p>a. fork，父shell进程的全局环境变量copy一份给子shell进程，被调用脚本执行完成之后返回给父shell进程，父shell进程继续执行剩下的指令；</p>
<p>b. source，是把被调用脚本加载到当前shell环境中执行，他们的定义的局部变量共享，在同一个进程中，被调用脚本任何对全局变量的操作均影响父shell进程全局变量；</p>
<p>c. exec， 也是fork一个子shell环境来执行被调用脚本，但是父shell环境的执行权会被剥夺，无论父shell脚本中的指令是否执行完成，都不再被执行，对着子shell进程的结束而结束；</p>
<p>9、环境变量PATH</p>
<p>PATH环境变量定义了各种shell环境搜索执行指令的路径；</p>
<p>通过软连接和别名alias让自定义脚本可以在当前shell环境中任意被调用：</p>
<p>a.查看PATH环境变量，任意选择一个当前用户有操作权限的，例/home/work/bin；</p>
<p>b.编写测试脚本run.sh，放在/home/work/shell/myCodes目录下，然后做软连接ln -s /home/work/shell/myCodes/run.sh /home/work/bin/run;</p>
<p>c.定义别名，先alias -p看一下，不要定义重复，然后定义别名alias run=”sh run”，完成；</p>
<p>​    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/IOS-ncnn使用1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hey Z">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信头像.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hey Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/IOS-ncnn使用1/" itemprop="url">IOS-ncnn使用1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T09:42:57+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOS/" itemprop="url" rel="index">
                    <span itemprop="name">IOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、ncnn入门</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/微信头像.jpg" alt="Hey Z">
            
              <p class="site-author-name" itemprop="name">Hey Z</p>
              <p class="site-description motion-element" itemprop="description">LIFE WAS LIKE A BOX OF CHOCOLATES</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Hey-Z" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://weibo.com/zhvhe" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-globe"></i>微博</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hey Z</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
